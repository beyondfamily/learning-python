# 数据类型详解-元组
# 元组和列表一样都是一组有序的数据的组合
# 元组中的元素一但定义不可以修改，因此元组称为 不可变数据类型

# 元组定义
'''
+ 定义空元组 变量 = (),或者 变量=tuple()
+ 还可以使用 变量 = (1,2,3) 定义含有数据的元组
+ 注意：如果元组中只有一个元素时，必须加逗号 变量=(1,)
+ 特例：变量=1,2,3 这种方式也可以定义为一个元组
'''


# 元组的切片操作
'''
vart = (1,2,3,4,5,5,4,3,2,1)
res = vart[:]  # 获取全部
res = vart[::] # 获取全部
res = vart[1:] # 从索引1开始获取到最后
res = vart[1:3] # 从索引1开始到索引3之前 #(2, 3) 左开右闭
res = vart[:3]   # 从索引 0 开始 到 索引 3之前
res = vart[1:5:2] # 从索引1开始到索引5之前，步进值为2
res = vart[::2]  # 从索引 0 开始 到 最后 ，步进值为2
res = vart[5:1:-1] # 从索引5开始 到索引 1，步进值为-1  倒着输出
'''


# 元组推导式 生成器
# 列表推导式结果返回了一个列表，元组推导式返回的是生成器
'''
语法：
    列表推导式 ==> [变量运算 for i in 容器]  ==> 结果 是一个 列表
    元组推导式 ==> (变量运算 for i in 容器)  ==> 结果 是一个 生成器  不是元组
   
# 生成器是什么？
生成器是一个特殊的迭代器，生成器可以自定义，也可以使用元组推导式去定义
生成器是按照某种算法去推算下一个数据或结果，只需要往内存中存储一个生成器，节约内存消耗，提升性能

# 语法：
1. 里面是推导式，外面是一个() 的结果就是一个生成器
2. 自定义生成器，含有yield关键字的函数就是生成器
   含有yield关键字的函数，返回的结果是一个迭代器，换句话说，生成器函数就是一个返回迭代器的函数
'''


# 如何使用操作生成器？
'''
varlist = [1,2,3,4,5,6,7,8,9]
# newlist = [i**2 for i in varlist]
# print(newlist) # [1, 4, 9, 16, 25, 36, 49, 64, 81]

# 元组推导式 生成器 generator
newt = (i**2 for i in varlist)
print(newt) # <generator object <genexpr> at 0x1104cd4d0>

# 使用next函数去调用
# print(next(newt)) #1
# print(next(newt)) #4

# 使用list或tuple函数进行操作
# print(list(newt)) 
# print(tuple(newt)) 

# 使用 for 进行遍历
# for i  in newt:
#     print(i)
'''


# 关于yield
def foo():
    print("starting...")

    while True:
        res = yield 4

        print("res:", res)


g = foo()  # 开始是没有反应的

print(next(g))  # 调用了next才会有反应

print("*" * 20)

print(next(g))
'''
1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)
2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环
3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前
两行(第一个是while上面的print的结果,第二个是return出的结果)是执行print(next(g))的结果，
4.程序执行print("*"*20)，输出20个*
5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的
赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的(因为刚才那个是return出去了，并没有给赋值操作的左边传参数)，所以这个时候res赋值是None,
所以接着下面的输出就是res:None,
6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.
到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于
“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着
上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。
'''

















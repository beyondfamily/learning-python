# 列表的定义
'''
+ 可以使用 中括号进行定义 []
+ 也可以使用 list函数 定义
+ 在定义列表中的元素时，需要在每个元素之间使用逗号，进行分隔。[1,2,3,4]
+ 列表中的元素可以是任意类型的，通常用于存放同类项目的集合
'''


# 列表的基本操作
'''
+ 列表定义-[],list()
+ 列表相加-拼接
+ 列表相乘-重复
+ 列表的下标- 获取,更新
+ 列表元素的添加-append()
+ 列表元素的删除
  + del 列表[下标]
  + pop()函数 删除元素
'''


# 列表中切片
'''
语法==> 列表[开始索引:结束索引:步进值]
1.列表[开始索引:]  ==> 从开始索引到列表的最后
2.列表[:结束值]    ==> 从开始到指定的结束索引之前
3.列表[开始索引:结束索引] ==> 从开始索引到指定结束索引之前
4.列表[开始索引:结束索引:步进值] ==> 从指定索引开始到指定索引前结束，按照指定步进进行取值切片
5.列表[:] 或 列表[::] ==> 所有列表元素的切片
6.列表[::-1]  ==> 倒着获取列表的元素

varlist = ['刘德华','张学友','张国荣','黎明','郭富城','小沈阳','刘能','宋小宝','赵四'] #位置是从0开始的
# 从开始索引到列表的最后
res = varlist[2:] # ['张国荣','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']
# 从开始到指定的结束索引之前
res = varlist[:2] # ['刘德华','张学友'] 
# 从开始索引到指定结束索引之前
res = varlist[2:6] # ['张国荣', '黎明', '郭富城', '小沈阳']  
# 从指定索引开始到指定索引前结束，按照指定步进进行取值切片
res = varlist[2:6:2] # ['张国荣', '郭富城'] # 左闭右开
# 所有列表元素的切片
res = varlist[:]
res = varlist[::]
# 倒着输出列表的元素
res = varlist[::-1]

# 从指定下标开始，到指定下标前结束，并替换为对应的数据(容器类型数据，会拆分成每个元素进行赋值)
# varlist[2:6] = ['a','b','c',1,2,3] # 不需要与要更新的元素个数对应  
#['刘德华', '张学友', 'a', 'b', 'c', 1, 2, 3, '刘能', '宋小宝', '赵四']
#其中的四个给替换成了六个
# varlist[2:6:2] = ['a','b'] # 需要与要更新的元素个数对应 # 左闭右开

# 切片删除
# del varlist[2:6]
# del varlist[2:6:2]
'''


# 列表相关函数
'''
varlist = ['刘德华','张学友','张国荣','张学友','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']

# 1.0.len()检测当前列表的长度，列表中元素的个数
res = len(varlist)

# 2.0.count()检测当前列表中指定元素出现的次数
res = varlist.count('张学友')

# 3.0.append()向列表的尾部追加新的元素
varlist.append('川哥')

# 4.0.insert()可以向列表中指定的索引位置添加新的元素，其余的数据向后移动一位
varlist.insert(20,'aa')

# 5.0.pop()可以对指定索引位置上的元素做 出栈 操作，返回出栈的元素 #pop有删除元素的作用
res = varlist.pop() # 默认会把列表中的最后一个元素 出栈
res = varlist.pop(2) # 会在列表中把指定索引的元素进行 出栈

# 栈的概念
----------------------------------------------------
出栈的意思
varlist = ['刘德华','张学友','张国荣','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']
print(varlist) #['刘德华','张学友','张国荣','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']
res = varlist.pop(2)
print(varlist) #['刘德华', '张学友', '黎明', '郭富城', '小沈阳', '刘能', '宋小宝', '赵四']张国荣就没了
print(res)#张国荣
----------------------------------------------------

varlist = [1,2,3,4,11,22,33,44,1,2,3,4]

# 6.0.remove()可以！！指定！！列表中的元素 进行 删除,只删除第一个。如果没有找到，则报错
res = varlist.remove(1)
res = varlist.remove('刘德华')

# 7.0.index()可以查找指定元素在列表中第一次出现的索引位置 返回的是元素的位置
# res = varlist.index(1)
# res = varlist.index(1,5,20) # 可以在指定索引范围内查找元素的索引位置 后两位是索引位置

# 8.0.extend() 接收一个容器类型的数据，把容器中的元素追加到原列表中
# varlist.extend('123')
# print(varlist) #  # ['刘德华', '张学友', '张国荣', '张学友', '黎明', '郭富城', '小沈阳', '刘能', '宋小宝', '赵四', '1', '2', '3']
# vartupe=(1,2,3)
# varlist.extend(vartupe) 
# print(varlist)#['刘德华', '张学友', '张国荣', '黎明', '郭富城', '小沈阳', '刘能', '宋小宝', '赵四', 1, 2, 3]

# 9.0.clear() # 清空列表内容
# varlist.clear()

# 10.0.reverse() 列表翻转
#  varlist.reverse()#['赵四', '宋小宝', '刘能', '小沈阳', '郭富城', '黎明', '张国荣', '张学友', '刘德华']

# 11.0.sort() 对列表进行排序
res = varlist.sort() # 默认对元素进行从小到大的排序
res = varlist.sort(reverse=True) # 对元素进行从大到小的排序
res = varlist.sort(key=abs) # 可以传递一个函数，按照函数的处理结果进行排序
# 也可以写做：res = sorted(varlsit) #两种写法
'''


# 浅拷贝
'''
浅拷贝只能拷贝列表中的一维元素，如果列表中存在二维元素或容器，则引用而不是拷贝
使用cpoy函数或者copy模块中的copy函数拷贝的都是浅拷贝

varlist = [1,2,3]
# 简单的拷贝 就可以把列表复制一份
newlist = varlist.copy()
# 对新拷贝的列表进行操作，也是独立的
del newlist[1]
# print(varlist,id(varlist))
# print(newlist,id(newlist))

# 多维列表
varlist = [1,2,3,['a','b','c']]
# 使用copy函数 拷贝一个多维列表
newlist = varlist.copy()
# 如果是一个被拷贝的列表，对它的多维列表元素进行操作时，会导致原列表中的多维列表也发生了变化

# for example
varlist = [1,2,3,['a','b','c']]
newlist = varlist.copy()
del newlist[3][1]
print(varlist,id(varlist)) # [1, 2, 3, ['a', 'c']] 1839821485248
print(newlist,id(newlist)) # [1, 2, 3, ['a', 'c']] 1839821497088
'''


# 深拷贝
'''
深拷贝就是不光拷贝了当前的列表，同时把列表中的多维元素或容器也拷贝了一份，而不是引用
使用copy模块中的 deepcopy 函数可以完成深拷贝
# 深拷贝 就是不光拷贝了当前的列表，同时把列表中的多维元素也拷贝了一份
import copy
# 使用 copy模块中 深拷贝方法 deepcopy
newlist = copy.deepcopy(varlist)
del newlist[3][1]
print(varlist)
print(newlist)
#
print(newlist[3],id(newlist[3]))
print(varlist[3],id(varlist[3]))
['a', 'c'] 4483351248
['a', 'b', 'c'] 4483003568
'''


# 列表推到式
'''
List-Comprehensions
列表推导式提供了一个更简单的创建列表的方法
常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。
采用一种表达式的当时，对数据进行过滤或处理，并且把结果组成一个新的列表

一，基本的列表推到式使用方式
结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据]
'''
# (1)假设我们想创建一个平方列表
# 1.0.使用普通方法完成
varlist = []
for i in range(10):
    varlist.append(i**2)
print(varlist)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 2.0.使用 map函数和list完成
varlist = list(map(lambda x: x**2, range(10)))
print(varlist)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 3.0.使用列表推到式完成 下面这个列表推到式和第一种方式是一样的
varlist = [i**2 for i in range(10)]
print(varlist)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]


# (2)'1234' ==> [2,4,6,8]
# 1.0.常规方法完成需求
varstr = '1234'
newlist = []
for i in varstr:
    newlist.append(int(i)*2)
print(newlist)  # [2, 4, 6, 8]

# 2.0.使用列表推到式完成上面的需求
newlist = [int(i)*2 for i in varstr]
print(newlist)  # [2, 4, 6, 8]

# 3.0.使用列表推到式+位运算完成
newlist = [int(i) << 1 for i in varstr] #左移动运算符
print(newlist)  # [2, 4, 6, 8] #输出算法还是十进制

# 带有判断条件的列表推到式
# (3)0-9 求所有的偶数，==> [0, 2, 4, 6, 8]
# 1.0.常规方法完成
newlist = []
for i in range(10):
    if i % 2 == 0:
        newlist.append(i)
print(newlist) # [0, 2, 4, 6, 8]

# 2.0.列表推到式完成
newlist = [i for i in range(10) if i % 2 == 0]
print(newlist)  # [0, 2, 4, 6, 8]

# 对于嵌套循环的列表推到式
# (4)下面这个 3x4的矩阵，它由3个长度为4的列表组成，交换其行和列
'''
[
 [1, 2, 3, 4],
 [5, 6, 7, 8],  
 [9, 10, 11, 12],
]
==>
[
    [1, 5, 9], 
    [2, 6, 10], 
    [3, 7, 11], 
    [4, 8, 12]
]
'''
arr = [
 [1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12],
]
# 1.0.常规方法完成
newlist = []
for i in range(4):
    res = []
    for row in arr:
        res.append(row[i])
    newlist.append(res)
print(newlist)

# 2.0.使用列表推到式完成
newlist = [[row[i] for row in arr] for i in range(4)]  # 先运行for i in range(4)
# -----------------
# |从外往里，从右往左|
# -----------------

newlist=[(e,f**2) for e in range(3) for f in range(5,15,5)]  # 从右往左
print(newlist) #[(0, 25), (0, 100), (1, 25), (1, 100), (2, 25), (2, 100)]
